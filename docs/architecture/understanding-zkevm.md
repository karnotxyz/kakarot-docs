---
title: zkEVM的概念
sidebar_position: 1
---

为了掌握zkEVM的概念，让我们首先了解什么是以太坊虚拟机(EVM)。

## 以太坊虚拟机(EVM)

### EVM 概述

从[以太坊基金会的定义](https://ethereum.org/developers/docs/evm#from-ledger-to-state-machine)开始:

> 以太坊的状态是一个大型数据结构，它不仅保存了所有账户
> 而平衡，只是一种机器状态，它可以从一个区块改变到另一个区块
> 根据一组预定义的规则，可以任意执行
> 机器代码。从块到块改变状态的具体规则是
> 由EVM定义。

从上文我们可以看出，以太坊区块链是一个分布式状态机，而[以太坊虚拟机](https://ethereum.org/developers/docs/evm) 是对物理计算机（虚拟机）的基于软件的仿真，用于操作（计算状态转换）该区块链。

需要注意的是，EVM 是一个确定性的执行环境。

- 确定性是指，无论网络中的哪个节点执行智能合约，只要输入相同，就会产生相同的输出。这对于维持整个网络的共识至关重要。
- 执行环境，即执行智能合约的地方。请注意，每个以太坊节点都运行一个 EVM 实例，允许它参与执行和验证智能合约和交易。
  - 例如，以太坊验证器同时运行一个共识客户端和一个执行客户端。执行客户端由 EVM 实现提供支持。
    这样，验证器就可以在本地重新运行交易，从而验证交易，以确保其正确性✅！

TL;DR - EVM 是用于在以太坊网络上运行逻辑的通用虚拟计算机。

### EVM 的架构

---

示意图 - Takenobu 绘制的 EVM 图：

![The EVM illustrated by Takenobu](../../static/diagrams/evm_takenobu.png)
资料来源:EVM插图，
https://takenobu-hs.github.io/downloads/ethereum_evm_illustrated.pdf

---

让我们用 Takenobu 提供的上图来描述一下 EVM 的机器结构。

1. 虚拟 ROM：包含 EVM 代码。一旦部署了智能合约、 其代码不可更改（尽管有代理模式 🧑‍🔬）。智能 合约代码在以太坊上被称为_不可变_。

2. 程序计数器 (PC)： 它记录 EVM 当前执行代码的位置。

3. 可用燃料（Gas）： EVM 中的每个操作都需要一定量的 "燃料"。"燃料"，它是衡量所需计算能力的单位。可用燃料可用气体字段跟踪交易还剩多少燃料才能继续运行。

4. 机器状态（µ）：这是机器的易失性状态，包括程序计数器、内存、栈等。它是易失性的，因为在交易之间会被重置。它不在交易内调用之间共享（例如，在一个交易中有 3 个不同的合约调用），尽管这将随着[瞬态存储](https://eips.ethereum.org/EIPS/eip-1153)的引入而改变。

5. 栈：EVM 是一种基于栈的机器，这意味着它使用一种称为栈的数据结构来存储数据。EVM 代码中的操作以各种方式操作栈。

6. 内存： 这是执行过程中存储数据的临时位置。它是易失性的，因为它会在事务或事务内部调用之间重置。

7. (账户）存储： 这是以太坊每个账户都有的长期存储。拥有的长期存储。与内存不同，存储是持久的，在不同的交易 甚至会话之间。这包括账户合约（智能 合约）和外部拥有的账户或 EOA（用户账户，如 您 Metamask 钱包中的账户！）。

8. 世界状态 (σ)： 这是整个以太坊系统的持久状态 包括所有账户（no.7）及其余额、存储、代码等。

之所以称为 "基于堆栈 "的架构，是因为其主要计算模式是通过数据堆栈进行的，而数据堆栈是一种后进先出（LIFO）结构。

Kakarot 是使用 Cairo 构建的 zkEVM。从本质上讲，这意味着我们已经使用 Cairo 将数字 1 到 8 写入了代码（同时依赖现有的 StarknetOS 客户端）。[Geth](https://geth.ethereum.org/) 团队用 Golang 完成了这项任务。[Reth](https://github.com/paradigmxyz/reth) 团队则用 Rust 完成了。恰好，Cairo 是经过设计验证的，而要使以太坊能够扩展，EVM 需要被证明！

## zk-Rollup 的概念

zk-Rollup 和 zkEVM 中的 zk 意味着“零知识”。它指的是一种密码学方法，通过这种方法，一方（证明者）可以向另一方（验证者）证明一个陈述是真实的。在 Kakarot zkEVM 的情况下，证明者（Rollup）向验证者（以太坊 L1）证明一批 L2 交易是有效的。zk-Rollup 通过批处理的概念帮助以太坊主网扩展：向以太坊 L1 提交更少的交易，让以太坊 L1 计算更少的逻辑，从而降低成本。

这些所谓批次的完整性在数学上是由零知识证明保证的(当它们不保护隐私时也称为有效性证明)。

要深入了解，您可以参考[关于零知识证明的高级文章](https://medium.com/starkware/stark-math-the-journey-begins-51bd2b063c71)， 由STARK证明的发明者Starkware写的。
要理解 zk-Rollups 的价值，重要的是要理解当在以太坊上执行交易时，网络中的所有完整节点都会在本地运行以验证其完整性。因此，为了保证网络的状态，每个交易都会被执行数十万次。zk-Rollups 的理念是只运行一次交易，计算该交易的完整性证明，然后仅验证该证明，而无需重新运行初始交易。幸运的是（对于我们和以太坊的 Rollup 中心化路线图而言），验证交易证明的成本远远低于重新运行相同交易的成本（渐近地呈指数级下降）。

由此产生了 zk-Rollups 协议。根据[以太坊网站](https://ethereum.org/developers/docs/scaling/zk-rollups#what-are-zk-rollups)：

> 零知识rollups（ZK-rollups）将交易捆绑（或 'roll up'）为
> 在链外执行的批次。链外计算减少了
> 必须发布到区块链上的数据。ZK-rollup 操作员提交
> 表示批处理中所有事务所需更改的摘要
> 而不是单独发送每个交易。它们也产生有效性
> 证明其更改正确性的证明。

TL;DR - 链下执行，链上验证，节省成本。

## 证明 EVM：从 EVM 到 zkEVM 的过渡意味着什么？

一个 zkEVM 简单来说就是与以太坊兼容的 zk-Rollup。这意味着用户应该能够与之交互，就像他们在与以太坊交互一样（或几乎一样）。例如，用户在 zkEVM 上将使用与以太坊 L1 上相同的工具，例如相同的钱包（如 Metamask）。开发者的智能合约应该能够在 zkEVM 上部署，而无需进行任何（或很少的）更改。

从加密学角度来看，这是非常强大的，因为加密部分被抽象化了。用户继续与他们熟悉的高级抽象层进行交互：即 EVM。在这个意义上，以太坊生态系统中创新的迭代式“基于现有工作”的方面得以保留。

在 zk-Rollup 生态系统中，其他参与者决定重新开始并与 EVM 断开兼容性。其中包括例如由 CairoVM 提供支持的 [Starknet](https://www.starknet.io/en)。Starknet 上的用户和开发者需要习惯使用新的工具和技术，但不必受到 EVM 遗留问题的困扰。Kakarot 则做出了略有不同的选择：EVM 将继续成为加密领域的主要公共抽象层，而 Cairo 将成为最强大的 zkVM。因此，同时进行以下操作是有意义的：

- 2024年构建EVM，
- 在未来的岁月里，把赌注押在开罗这座强国身上。

Kakarot用户将同时受益于以太坊网络效应和的创新。

请注意，zkEVM 还指代用于证明与以太坊兼容的交易和区块的软件。它指的是用于从 EVM 交易转换为零知识（或有效性）证明的代码。zkEVM 的实现可以是低级的（在所谓的“circuits”级别）或高级的（使用中间 zkVM）。[Scroll](https://scroll.io/) 是前者的体现，而 Kakarot 是后者的体现。

TL;DR: 在 Layer 2 上执行与以太坊兼容的交易，进行链下证明，将其捆绑并在以太坊 L1 上验证。节省成本，获得现有生态系统的好处：以太坊社区。
